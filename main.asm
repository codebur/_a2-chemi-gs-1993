	keep Main***************************************************************** 		           ChemiGS			       ****************************************************************** A Drawing Program for Chemical Structures		       ** (c) 1992-93 by Urs Hochstrasser			       ** Buendtenweg 6			       ** 5105 AUENSTEIN (SWITZERLAND)			       ****************************************************************** Module MAIN****************************************************************** USES ...*	mcopy	Main.macros	copy	equates.asm****************************************************************** MAIN ROUTINE*Main	start	using	Globals	phk	plb	~TLStartup	pha	                         gMemID:=MMStartup;	~MMstartup	pla	sta	gMemID	ora	#$0100	sta	gMyID	make private ID for all mem requests	lda	#1	sta	fDoAbout	jsr	Hello	pha		gToolRef:=StartupTools(...	pha	~StartupTools gMemID,#RefIsResource,#kTools	sta	gToolErr	pl4	gToolRef	lda	gToolErr	bne	exit	Shutdown on Tool Startup Error	jsr	InitGlobals	lda	fDoAbout	beq	noAbout	jsr	ShowAboutnoAbout	anop	jsr	SetUpMenus	jsr	SetUpWindows	jsr	HideAbout	jsr	FirstFile	~InitCursor	jsr	EventLoopexit	~DisposeAll gMyID	~ShutDownTools #RefIsHandle,gToolRef	~MMShutDown gMemID         ~TLShutDown	QuitGS quitParmquitParm	ds	8	endFirstFile start	using	Globals	using	Parms	ph4	#0	~NewHandle #1,gMyID,#0,#0	pl4	messaHandle	~MessageCenter #2,#1,messaHandle	get Message from Finder	bcc	l4	brl	l1	...no message found...l4	anop	lda	messaHandle	ldx	messaHandle+2	jsr	Deref	sta	messaPtr	stx	messaPtr+2	move4	messaPtr,0	add4	0,#6	lda	[0]	sta	message	cmp	#2	bcc	l3         brl	l2	>= 2  NO VALID MESSAGE!l3	anop	inc4	0	put pointer one byte before path str*	brk	lda	[0]	...and convert it to a Cl1 input string	xba	and	#$00FF	sta	[0]	sta	pathLen	move4	0,Opath	ldy	pathLen	load path str length into y	add4	0,#1	0 points 1 byt before 1st ch in path strloop	lda	[0],y	and	#$00FF	cmp	#'/'	beq	match	cmp	#':'	beq match	dbne	y,loopmatch	sty	temp	sub2	pathLen,temp,nameLen	add4	0,temp	dec4	0	lda	nameLen*	xba	sta	nameLen2	inc4	0	inc4	nameLen	ph4	#0	~NewHandle nameLen,gMyID,#0,#0	pl4	gTitleH	~PtrToHand 0,gTitleH,nameLen	~PtrToHand #nameLen2,gTitleH,#1	lda	gTitleH	ldx	gTitleH+2	jsr	Deref	sta	gTitlePtr	stx	gTitlePtr+2	inc	fFirstFile	jsr	Open2	lda	message	cmp	#1	bne	l2	jsr	DoPrintl2	~MessageCenter #3,#1,messaHandle	delete the Message	~DisposeHandle messaHandle	bra	exitl1	jsr	DoNewexit	rtsmessaHandle ds	4thePtr	ds	4messaPtr	ds	4message	ds	2nameLen	ds	4pathLen	ds	4temp	ds	4nameLen2	ds	2	end****************************************************************** General SubroutinesError	start		if there is a Tool error, display it	using Globals	php	lda	gToolErr	beq	exit	~SysBeep	ph2	#0	~ErrorWindow #1,#0,gToolErr	pl2	dummyexit	lda	gToolErr	plp	rtsdummy	ds	2	endSetUpMenus start	using Globals	ph4	#0	~NewMenuBar2 #RefIsResource,#kMBarID,#0	pl4	myBar	~SetsysBar myBar	~SetMenuBar #0	~FixAppleMenu #kAppleM	pha	~FixMenuBar	pl2	heigth	~DrawMenuBar	rtsheigth	ds	2myBar	ds	4	end		END of SetUPMenusEventLoop start	using Globals	stz	gDoneevloop	jsr CheckFrontW	pha	~TaskMaster #everyEvent,#gMainEvt	pl2	code	lda	code	cmp	#wInGoAway	bne	l2	jsr	DoClose	brl	exitl2	cmp	#wInMenuBar	bne	l1	jsr	HandleMenu	brl	exitl1	cmp	#wInSpecial	bne	l3	jsr	HandleMenu	brl	exit	???//l3	anop		*** new stuff	cmp	#wInContent	bne	l4         jsr	HandleContent	in module WINDOWS	brl	exit	???//l4	cmp	#wInInfo	bne	exit	jsr	HandleInfo	in module WINDOWSexit	lda	gDone	bne	exit2	lda	gTaskDta	see whether Tool win needs redrawing	and	#$7FFF	cmp	#wInGrow	beq	doUpD	@@@@@@@@	cmp	#wInDrag	beq	doUpD	cmp	#wInZoom	beq	doUpD	cmp	#wClickCalled	beq	doUpD* Insert Null Event Handler Here...	jsr	HndlDiskInsert	bra	loopdoUpD	jsr	UpdateToolWinloop	anop	jsr	AdjustCursor	jmp	evloopexit2	rtscode	ds	2	endCheckFrontW start	using Globals	ph4	#0	~FrontWindow	pl4	theWindow	lda	theWindow	same window as last time?	cmp	gLastWindow	bne	changed	lda	theWindow+2	cmp	gLastWindow+2	bne	changedexit1	rtschanged	anop	stz	newCursor	jsr	UpdateToolWin	lda	theWindow	Window has changed, but...	ora	theWindow+2	bne	l4	brl	l1                       ...no Window at all!l4	pha		is it a DA?	~GetSysWFlag theWindow	pla	beq	noDA	no DA, so skip	~EnableMItem #255	It's a DA! (enable Close Item)	~SetMenuFlag #$FF7F,#3	enable Edit Menu	~DrawMenuBar	brl	exitnoDA     anop	lda	theWindow	cmp	gToolWin	bne	l2	lda	theWindow+2	cmp	gToolWin+2	bne	l2	bra	l1l2	jsr	enableItems	move4 theWindow,gTaskDta	*** is it secure enough?...***	jsr	SelDataWin	bra	exitl1	anop		no Window there...	jsr	disableItemsexit	move4 theWindow,glastWindow	rtsenableItems anop	lda	fEnabled	already enabled?	bne	en1	yes, so skip	~EnableMItem #255	Close	~EnableMItem #260	Save	~EnableMItem #261	Save As	~EnableMItem #262	Revert	~EnableMItem #263	Page Setup	~EnableMItem #264	Print	~SetMenuFlag #enableMenu,#3	Edit Menu	~DrawMenuBar	inc	fEnabled	set 'fEnabled' flagen1	rtsdisableItems anop	stz	fEnabled	~DisableMItem #255	Close	~DisableMItem #260	Save	~DisableMItem #261	Save As	~DisableMItem #262	Revert	~DisableMItem #263	Page Setup	~DisableMItem #264	Print	~SetMenuFlag #disableMenu,#3	Edit Menu	~DrawMenuBar	rtstheWindow ds	4theHandle ds	4fEnabled	ds	2	Flag, TRUE if Items enabled	endIgnore	start	rts	endDeref	start		Derefs and locks handle passed in	sta	0	a,x. Result passed back in a,x	stx	2	trashes 0 on DP	ldy	#4	lda	[0],y	sta	lockState	ora	#$8000	sta	[0],y	dey	dey	lda	[0],y	tax	lda	[0]	rtsUnlock	entry		Unlocks the handle passed in x,a	sta	0	trases 0 on DP	stx	2	ldy	#4	lda	lockState	better?...*	lda	[0],y*	and	#$7FFF	sta	[0],y	rtslockState ds	2	endGetField start	sta	0	stx	2	ldy	#0loop	lda	[0],y	copy input SGRecord into local area	sta	handle,y	iny	iny	cpy	#14	length of the SGRecord	bcc	loop	lda	offset	clc	adc	length	sta	endf	_Deref handle,0	move4	destptr,4	sub4	4,offset	ldy	offsetloop2	lda	[0],y	sta	[4],y	iny	iny	cpy	endf	bcc	loop2	_Unlock handle	rtshandle	ds	4offset	ds	4destptr	ds	4length	ds	2endf	ds	2	endSetField start	sta	0	stx	2	ldy	#0loop	lda	[0],y	copy input SGRecord into local area	sta	handle,y	iny	iny	cpy	#14	length of the SGRecord	bcc	loop	lda	offset	clc	adc	length	sta	endf	_Deref handle,4	trashes 0,1!!!!!!!!	move4	sourceptr,0	sub4	0,offset	ldy	offsetloop2	lda	[0],y	sta	[4],y	iny	iny	cpy	endf	bcc	loop2	_Unlock handle	rtshandle	ds	4offset	ds	4sourceptr ds	4length	ds	2endf	ds	2	end    Test	start	~SysBeep	rts	endSetUpWindows start	using Globals	ph4	#0	Set Up Tool Window	~NewWindow2 #0,#0,#0,#0,#RefIsResource,#kToolWID,#rWindParam1	pl4	gToolWin	~SetContentDraw #DrawToolWin,gToolWin         ph4	#0	~NewWindow2 #0,#0,#0,#0,#RefIsResource,#kEasterWID,#rWindParam1	pl4	gEasterWin	ph4	#0	~NewWindow2 #0,#0,#0,#0,#RefIsResource,#kPrefWID,#rWindParam1	pl4	gPrefWin	ph4	#0	~NewWindow2 #0,#0,#0,#0,#RefIsResource,#kHelpWID,#rWindParam1	pl4	gHelpWin	rts	end**** Altes DoAbout ****************************	~SetForeColor #3	white*	~SetBackColor #0	black*	~SetTextMode #modeCopy**	~MoveTo gCopyLoc,gCopyLoc+2**	~DrawString #Copyright**	~MoveTo gCopyLoc+4,gCopyLoc+6**	~DrawString #VersionStr**********************************************ShowAbout start	using	Globals	stz	fWaitForKeyDoAbout	entry	ph4	#0	~FrontWindow	pl4	theWindow	~SendBehind #-1,gAboutWin*	~ShowHide #1,gAboutWin	~ShowWindow gAboutWin	~SelectWindow gAboutWin	~BeginUpdate gAboutWin	~DrawControls gAboutWin	~EndUpdate gAboutWin	lda	fWaitForKey	beq	noWaitloop	pha	~GetNextEvent #$A,#eventRec	MouseDown, KeyDown	pla	beq loopHideAbout entry	~ShowHide #0,gAboutWin	~SelectWindow theWindownoWait	anop	lda	#1	sta	fWaitForKey	set again the flag for next call	rtstheWindow ds	4eventRec	ds	16	endDoPrefs	start		*** do sth more...	using	Globals	ph4	#0	~FrontWindow	pl4	theWindow	~SendBehind #-1,gPrefWin	~ShowHide #1,gPrefWin	~SelectWindow gPrefWin	~BeginUpdate gPrefWin	~DrawControls gPrefWin	~EndUpdate gPrefWinloop	pha	~GetNextEvent #$A,#eventRec	MouseDown, KeyDown	pla	beq loop	~ShowHide #0,gPrefWin	~SelectWindow theWindow	rtstheWindow ds	4eventRec	ds	16	endDoHelp	start		*** do sth more...	using	Globals	ph4	#0	~FrontWindow	pl4	theWindow	~SendBehind #-1,gHelpWin	~ShowHide #1,gHelpWin	~SelectWindow gHelpWin	~BeginUpdate gHelpWin	~DrawControls gHelpWin	~EndUpdate gHelpWinloop	pha	~GetNextEvent #$A,#eventRec	MouseDown, KeyDown	pla	beq loop	~ShowHide #0,gHelpWin	~SelectWindow theWindow	rtstheWindow ds	4eventRec	ds	16	endForeColor start	Generates gForePat from colorNum	using	Globals	colorNum in A	and	#$F	sta	temp	asl	a	asl	a	asl	a	asl	a	ora	temp	sta	temp	xba		hier musst du noch schieben um 4 bit	ora	temp	ldx	#0loop	sta	forePat,x	inx	inx	cpx	#32	bcc	loop	~SetPenPat #forePat	rtsBackColor entry	Same for Background Pattern	and	#$F	sta	temp	asl	a	asl	a	asl	a	asl	a	ora	temp	sta	temp	xba	ora	temp	ldx	#0loop2	sta	backPat,x	inx	inx	cpx	#32	bcc	loop2	~SetBackPat #backPat	rtstemp	ds	2forePat	ds	32backPat	ds	32	endHello	start	using	Globals	ph4	#0	~NewHandle #1,gMyID,#0,#0	pl4	messaHandle	~MessageCenter #2,#1,messaHandle	get Message from Finder	bcs	noMessa	brl	exitnoMessa	anop	OpenGS TOpenParm	Load Title Screen	bcs	exit2	if none -> skip it	stz	fDoAbout	SHORT	M	lda	$E0C034	sta	border	Save Border Color	and	#$F0	ora	#$9	Set Border Color to Orange	sta	$E0C034	lda	$E0C029	Enable Super Hires	ora	#$C0	sta	$E0C029	LONG	M*	OpenGS TOpenParm	Already opened!	lda	TOpenParm+2	sta	TReadParm+2	sta	TCloseParm+2	ReadGS TReadParm*	CloseGS TCloseParm	Close later (closes attempt also)	SHORT M*	lda	$E0C010	clear Keyboard strobe	stz	VBLcount	clear own VBL counterloop	lda	$E0C019	bit 7 = 1 if not VBL	and	#$80	cmp	oldVBL         beq	noVBL         inc	VBLcountnoVBL	sta	oldVBL	lda	VBLcount         cmp	#240	bcc	Loop	lda	border	restore Border color	sta	$E0C034	LONG	M	~DisposeHandle messaHandleexit2	CloseGS TCloseParmexit	anop	rts	TOpenParm dc	i2'3'	pCount	ds	2	refNum	dc	i4'TitleScrn'	pathname pointer	dc	i2'1'	requestAccess	ds	2	resourceNumber	ds	2	access	ds	2	fileType	ds	4	auxType	ds	2	storageType	ds	8	createDateTime	ds	8	modDateTime	ds	4	optionList	ds	4	eof	ds	4	blocksUsed	ds	4	resourceEOF	ds	4	resourceBlocksTReadParm dc	i2'4'	pCount	ds	2	refNumRdBuf	dc	i4'$00E12000'	dataBufferRrCount	dc	i4'32767'	requestCount	ds	4	transferCount	ds	2	cachePriority         TCloseParm dc	i2'1'	ds	2	refNumTitleScrn DOSIN 'Title.Scrn'border	ds	2messaHandle ds	4VBLcount	ds	2oldVBL	dc	i2'$FF'	end